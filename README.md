# Алгоритмический мини-пакет (Лабораторная работа №3)
Cтудент: Ларьков Андрей Александрович
Группа: М8О-103БВ-25


## Описание проекта

Проект представляет собой алгоритмический мини-пакет для работы с сортировками, генераторами тестовых данных, структурами данных (стек и очередь), а также бенчмарками. Он включает в себя удобный CLI для интерактивного взаимодействия и автоматического тестирования алгоритмов.

Проект позволяет:
- Изучать и тестировать классические алгоритмы сортировки.
- Генерировать массивы различных типов для тестирования алгоритмов.
- Использовать структуры данных с разными внутренними реализациями.
- Проводить замеры производительности сортировок.

---

## Возможности

### Сортировки

В проекте реализованы следующие алгоритмы сортировки:
- **Пузырьковая (`bubble_sort`)**
- **Быстрая (`quick_sort`)**
- **Слиянием (`merge_sort`)**
- **Пирамидальная (`heap_sort`)**
- **Подсчет (`count_sort`)**
- **Разрядная (`radix_sort`)**
- **Ведерная (`bucket_sort`)**

Особенности:
- Сортировки `quick_sort`, `merge_sort`, `heap_sort` и `bubble_sort` поддерживают **ключи (`key`)** и **компараторы (`cmp`)** для гибкого сравнения элементов.
- `count_sort`, `radix_sort` и `bucket_sort` работают только с числами и не поддерживают ключи и компараторы.

### Генераторы массивов

Для тестирования алгоритмов можно использовать генераторы:
- **Случайные целые числа (`rand_int_array`)**
  Можно задавать диапазон (`lo`, `hi`), уникальность элементов (`distinct`) и `seed`.
- **Почти отсортированные (`nearly_sorted`)**
  Позволяет задать количество случайных перестановок (`swaps`) и `seed`.
- **Массивы с множеством дубликатов (`many_duplicates`)**
  Можно задать количество уникальных элементов (`k_unique`) и `seed`.
- **Обратно отсортированные (`reverse_sorted`)**
  Создает массив в убывающем порядке.
- **Случайные числа с плавающей точкой (`rand_float_array`)**
  Позволяет задавать диапазон (`lo`, `hi`) и `seed`.

Особенности:
- Генерация массивов может быть воспроизводимой с помощью параметра `seed`.
- Позволяет создавать массивы для тестирование сортировок и бенчмарков.

## Структуры данных

### Стек

Реализованы три типа стека:

| Реализация | Сложность `push` | Сложность `pop` | Сложность `peek` | Сложность `min()` | Особенности |
|------------|-----------------|----------------|-----------------|-----------------|-------------|
| На списках (`Stack`) | O(1) | O(1) | O(1) | O(1) (через вспомогательный стек) | Прямая работа с Python list |
| На очередях (`QueueStack`) | O(n) | O(1) | O(1) | O(1) (через дополнительную очередь `mins`) | Использует очередь для имитации стека |
| На связном списке (`LinkedStack`) | O(1) | O(1) | O(1) | O(1) (каждый Node хранит текущий минимум) | Классическая реализация через Node(value, next, current_min) |

### Очередь

### Очередь

Реализованы три типа очереди с поддержкой всех операций, включая `min()` за O(1):

| Реализация | Сложность `enqueue` | Сложность `dequeue` | Сложность `front` | Сложность `min()` | Особенности                                                                          |
|------------|-------------------|--------------------|-----------------|-----------------|--------------------------------------------------------------------------------------|
| На списках (`ListQueue`) | O(1) append / O(n) pop(0) | O(n) pop(0) | O(1) | O(1) | Для min() используется вспомогательный list                                          |
| На стеках (`StacksQueue`) | O(1) амортизировано | O(1) амортизировано | O(1) | O(1) | Два стека(in_stack, out_stack)                                                       |
| На связном списке (`LinkedQueue`) | O(1) | O(1) | O(1) | O(1) | Каждый MinNode хранит ссылку на предыдущий и следующий элемент, чтобы min() был O(1) |

**Примечание:** Все очереди поддерживают получение минимального элемента за константное время, аналогично реализации стеков.

---


### CLI

CLI позволяет:
- Вызывать сортировки на переданных или сгенерированных массивах.
- Использовать ключи и компараторы в поддерживаемых сортировках.
- Интерактивно работать со стеком и очередью.
- Генерировать массивы различных типов и сразу сортировать их.
- Проводить бенчмарки сортировок и выводить результаты в JSON.

Примеры команд:

```bash
# Сортировка конкретного массива
python3 -m src.cli sort quick "[5,3,1,4]"

# Сортировка с ключом и компаратором
python3 -m src.cli sort quick "[5,-3,1]" --key abs --cmp reverse
python -m src.cli sort bubble "[-10, 5, -2, 3]" --key abs --cmp desc

# Генерация и сортировка массива
python3 -m src.cli sort-generated quick --generator dups --size 15 --k-unique 5 --seed 123
python -m src.cli sort-generated merge --size 20 --generator random

# Генерация массивов отдельно
python3 -m src.cli gen rand 10 0 50
python3 -m src.cli gen nearly 10 3
python3 -m src.cli gen dups 10 5
python3 -m src.cli gen rev 10
python3 -m src.cli gen float 10 0 1

# Интерактивный стек
python3 -m src.cli stack deque

# Интерактивная очередь
python3 -m src.cli queue linked

# Бенчмарки

# 1. Запуск стандартного набора тестов
python -m src.cli bench

# 2. Кастомный бенчмарк: сравнение QuickSort и MergeSort
python -m src.cli bench-custom -a quick -a merge -s 100 -s 1000 -s 5000 --generator dups


# Список всех комманд
python -m src.cli --help
```

# Основные бенчмарки сортировок
Результаты бенчмарков различных алгоритмов сортировки на разных типах данных (время в секундах).

### Small Random
| Алгоритм | Время сортировки |
|----------|------------------|
| Count    | **0.00005083**   |
| Radix    | 0.00018500       |
| Quick    | 0.00035871       |
| Bucket   | 0.00057496       |
| Merge    | 0.00113058       |
| Heap     | 0.00291125       |
| Bubble   | 0.03546575       |

### Big Random
| Алгоритм | Время сортировки |
|----------|----------|
| Count    | **0.00014229** |
| Radix    | 0.00064379 |
| Bucket   | 0.00140883 |
| Quick    | 0.00152471 |
| Merge    | 0.00628792 |
| Heap     | 0.01473567 |
| Bubble   | 0.83136508 |

### Reverse Sorted
| Алгоритм | Время сортировки |
|----------|----------|
| Count    | **0.00009499** |
| Radix    | 0.00018983 |
| Bucket   | 0.00022171 |
| Quick    | 0.00052021 |
| Merge    | 0.00070242 |
| Heap     | 0.00228875 |
| Bubble   | 0.03619900 |

### Nearly Sorted
| Алгоритм | Время сортировки |
|----------|----------|
| Count    | **0.00010208** |
| Radix    | 0.00016454 |
| Bucket   | 0.00021567 |
| Quick    | 0.00055250 |
| Merge    | 0.00079808 |
| Heap     | 0.00257300 |
| Bubble   | 0.02457900 |

### Many Duplicates
| Алгоритм | Время сортировки |
|----------|----------|
| Quick    | **0.00011113** |
| Radix    | 0.00019429 |
| Count    | 0.00021842 |
| Bucket   | 0.00028925 |
| Merge    | 0.00099350 |
| Heap     | 0.00203367 |
| Bubble   | 0.03232800 |

### Many Duplicates (Big)
| Алгоритм | Время сортировки |
|----------|----------|
| Count    | **0.00084200** |
| Quick    | 0.00088317 |
| Radix    | 0.00152867 |
| Bucket   | 0.00222325 |
| Merge    | 0.01013342 |
| Heap     | 0.02184317 |
| Bubble   | 2.25630654 |

# Итог

1. **Лучший алгоритм:** Counting Sort — показывает минимальное время на большинстве наборов, когда применим (при ограниченном диапазоне значений).
2. **Если Counting Sort неприменим:** Radix Sort — стабильно второй по эффективности.
3. **Лучшая сравнительная сортировка:** Quick Sort — быстро работает на всех наборах, особенно с большим количеством дубликатов.
4. **Худшая сортировка:** Bubble Sort — на порядки медленнее остальных.
